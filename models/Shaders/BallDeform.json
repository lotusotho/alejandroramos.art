{
  "id": 5371,
  "name": "BallDeform",
  "fragment": "#define F4 0.309016994374947451\n#define PI 3.14159\n\nprecision highp float;\nprecision highp int;\nuniform vec3 Big_Wiggles1627054260628_441_color;\nuniform float time;\nuniform vec2 uvScale;\nuniform vec3 Tiling_4D_Perlin_Noise1627059836531_99_color;\nuniform float Tiling_4D_Perlin_Noise1627059836531_99_speed;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform vec3 New_Basic_Shader1627059930592_142_color;\nuniform vec3 New_Basic_Shader1627059930592_142_lightPosition;\nuniform sampler2D iChannel0;\nuniform vec3 LighterGrade1627060293378_181_color;\nuniform vec3 color2;\nuniform vec3 LighterGrade1627060293378_181_lightPosition;\nvarying float vNoise;\nvarying vec2 Tiling_4D_Perlin_Noise1627059836531_99_vUv;\nvec4 Tiling_4D_Perlin_Noise1627059836531_99_mod289(vec4 x) \n                                                {\n                                                    return x - floor(x * (1.0 / 289.0)) * 289.0;\n                                                }\nfloat Tiling_4D_Perlin_Noise1627059836531_99_mod289(float x) \n                                                {\n                                                    return x - floor(x * (1.0 / 289.0)) * 289.0;\n                                                }\nvec4 Tiling_4D_Perlin_Noise1627059836531_99_permute(vec4 x) \n                                                {\n                                                    return Tiling_4D_Perlin_Noise1627059836531_99_mod289(((x * 34.0) + 1.0) * x);\n                                                }\nfloat Tiling_4D_Perlin_Noise1627059836531_99_permute(float x) \n                                                {\n                                                    return Tiling_4D_Perlin_Noise1627059836531_99_mod289(((x * 34.0) + 1.0) * x);\n                                                }\nvec4 Tiling_4D_Perlin_Noise1627059836531_99_taylorInvSqrt(vec4 r) \n                                                {\n                                                    return 1.79284291400159 - 0.85373472095314 * r;\n                                                }\nfloat Tiling_4D_Perlin_Noise1627059836531_99_taylorInvSqrt(float r) \n                                                {\n                                                    return 1.79284291400159 - 0.85373472095314 * r;\n                                                }\nvec4 grad4(float j, vec4 ip) \n                                                {\n                                                    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n                                                    vec4 p, s;\n                                                    p.xyz = floor(fract(vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n                                                    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n                                                    s = vec4(lessThan(p, vec4(0.0)));\n                                                    p.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www;\n                                                    return p;\n                                                }\nfloat snoise(vec4 v) \n                                                {\n                                                    const vec4 C = vec4(0.138196601125011, 0.276393202250021, 0.414589803375032, -0.447213595499958);\n                                                    vec4 i = floor(v + dot(v, vec4(F4)));\n                                                    vec4 x0 = v - i + dot(i, C.xxxx);\n                                                    vec4 i0;\n                                                    vec3 isX = step(x0.yzw, x0.xxx);\n                                                    vec3 isYZ = step(x0.zww, x0.yyz);\n                                                    i0.x = isX.x + isX.y + isX.z;\n                                                    i0.yzw = 1.0 - isX;\n                                                    i0.y += isYZ.x + isYZ.y;\n                                                    i0.zw += 1.0 - isYZ.xy;\n                                                    i0.z += isYZ.z;\n                                                    i0.w += 1.0 - isYZ.z;\n                                                    vec4 i3 = clamp(i0, 0.0, 1.0);\n                                                    vec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);\n                                                    vec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);\n                                                    vec4 x1 = x0 - i1 + C.xxxx;\n                                                    vec4 x2 = x0 - i2 + C.yyyy;\n                                                    vec4 x3 = x0 - i3 + C.zzzz;\n                                                    vec4 x4 = x0 + C.wwww;\n                                                    i = Tiling_4D_Perlin_Noise1627059836531_99_mod289(i);\n                                                    float j0 = Tiling_4D_Perlin_Noise1627059836531_99_permute(Tiling_4D_Perlin_Noise1627059836531_99_permute(Tiling_4D_Perlin_Noise1627059836531_99_permute(Tiling_4D_Perlin_Noise1627059836531_99_permute(i.w) + i.z) + i.y) + i.x);\n                                                    vec4 j1 = Tiling_4D_Perlin_Noise1627059836531_99_permute(Tiling_4D_Perlin_Noise1627059836531_99_permute(Tiling_4D_Perlin_Noise1627059836531_99_permute(Tiling_4D_Perlin_Noise1627059836531_99_permute(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n                                                    vec4 ip = vec4(1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0);\n                                                    vec4 p0 = grad4(j0, ip);\n                                                    vec4 p1 = grad4(j1.x, ip);\n                                                    vec4 p2 = grad4(j1.y, ip);\n                                                    vec4 p3 = grad4(j1.z, ip);\n                                                    vec4 p4 = grad4(j1.w, ip);\n                                                    vec4 norm = Tiling_4D_Perlin_Noise1627059836531_99_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n                                                    p0 *= norm.x;\n                                                    p1 *= norm.y;\n                                                    p2 *= norm.z;\n                                                    p3 *= norm.w;\n                                                    p4 *= Tiling_4D_Perlin_Noise1627059836531_99_taylorInvSqrt(dot(p4, p4));\n                                                    vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n                                                    vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n                                                    m0 = m0 * m0;\n                                                    m1 = m1 * m1;\n                                                    return 49.0 * (dot(m0 * m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1 * m1, vec2(dot(p3, x3), dot(p4, x4))));\n                                                }\nfloat surface(vec4 coord) \n                                                {\n                                                    float n = 0.0;\n                                                    n += 0.25 * abs(snoise(coord * 4.0));\n                                                    n += 0.5 * abs(snoise(coord * 8.0));\n                                                    n += 0.25 * abs(snoise(coord * 16.0));\n                                                    n += 0.125 * abs(snoise(coord * 32.0));\n                                                    return n;\n                                                }\nvarying vec3 New_Basic_Shader1627059930592_142_vPosition;\nvarying vec3 New_Basic_Shader1627059930592_142_vNormal;\nvarying vec2 New_Basic_Shader1627059930592_142_vUv;\nvarying vec2 New_Basic_Shader1627059930592_142_vUv2;\nvec3 _BaseWaterColor = (vec3(22., 79., 86.) / 255.);\nvec3 _LightWaterColor = (vec3(0., 214., 10.) / 255.);\nconst float SC = 10.;\nfloat waterHeight = 100.;\nfloat waterTranDeep = 10.;\nvec3 lightDir = normalize(vec3(0.5, 0.6, 0.));\nconst mat2 m2 = mat2(0.60, -0.80, 0.80, 0.60);\nconst mat3 m3 = mat3(0.00, 0.80, 0.60, -0.80, 0.36, -0.48, -0.60, -0.48, 0.64);\nfloat Noise(in vec3 x) \n                                                {\n                                                    vec3 p = floor(x);\n                                                    vec3 f = fract(x);\n                                                    f = f * f * (3.0 - 2.0 * f);\n                                                    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n                                                    vec2 rg = texture2D(iChannel0, (uv + 0.5) / 256.0, 0.0).yx;\n                                                    return mix(rg.x, rg.y, f.z);\n                                                }\nfloat Noise3D(in vec3 p) \n                                                {\n                                                    const vec3 s = vec3(7, 157, 113);\n                                                    vec3 ip = floor(p);\n                                                    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n                                                    p -= ip;\n                                                    p = p * p * (3. - 2. * p);\n                                                    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n                                                    h.xy = mix(h.xz, h.yw, p.y);\n                                                    return mix(h.x, h.y, p.z);\n                                                }\nfloat FBM(in vec3 p) \n                                                {\n                                                    float n = 0.0;\n                                                    n += 0.50000 * Noise(p * 1.0);\n                                                    n += 0.25000 * Noise(p * 2.0);\n                                                    n += 0.12500 * Noise(p * 4.0);\n                                                    n += 0.06250 * Noise(p * 8.0);\n                                                    n += 0.03125 * Noise(p * 16.0);\n                                                    return n / 0.984375;\n                                                }\nfloat WaterMap(vec3 pos) \n                                                {\n                                                    return FBM(vec3(pos.xz, time * 0.3)) * 1.;\n                                                }\nvec3 WaterNormal(vec3 pos, float rz) \n                                                {\n                                                    float EPSILON = rz * rz * 0.002;\n                                                    vec3 dx = vec3(EPSILON, 0., 0.);\n                                                    vec3 dz = vec3(0., 0., EPSILON);\n                                                    vec3 normal = vec3(0., 1., 0.);\n                                                    float bumpfactor = 0.3 * pow(1. - clamp((rz) / 1000., 0., 1.), 6.);\n                                                    normal.x = -bumpfactor * (WaterMap(pos + dx) - WaterMap(pos - dx)) / (2. * EPSILON);\n                                                    normal.z = -bumpfactor * (WaterMap(pos + dz) - WaterMap(pos - dz)) / (2. * EPSILON);\n                                                    return normalize(normal);\n                                                }\nvec3 InitCam(in vec2 fragCoord) \n                                                {\n                                                    vec2 iResolution = vec2(1920.0, 969.0);\n                                                    vec2 iMouse = vec2(1.0, 1.0);\n                                                    vec2 uv = fragCoord.xy / iResolution.xy;\n                                                    vec2 p = fragCoord.xy / iResolution.xy - 0.5;\n                                                    vec2 q = fragCoord.xy / iResolution.xy;\n                                                    p.x *= iResolution.x / iResolution.y;\n                                                    vec2 mo = iMouse.xy / iResolution.xy - .5;\n                                                    mo = (mo == vec2(-.5)) ? mo = vec2(-0, -0.03) : mo;\n                                                    mo.x *= iResolution.x / iResolution.y * 3.14159;\n                                                    mo.x += smoothstep(0.6, 1., 0.5 + 0.5) - 1.5;\n                                                    vec3 eyedir = normalize(vec3(cos(mo.x), mo.y * 2. - 0.2 + sin(1.57) * 0.1, sin(mo.x)));\n                                                    vec3 rightdir = normalize(vec3(cos(mo.x + 1.5708), 0., sin(mo.x + 1.5708)));\n                                                    vec3 updir = normalize(cross(rightdir, eyedir));\n                                                    vec3 rd = normalize((p.x * rightdir + p.y * updir) * 1. + eyedir);\n                                                    return rd;\n                                                }\nfloat TerrainH(in vec2 x) \n                                                {\n                                                    vec2 p = x * 0.03 / SC;\n                                                    float a = 0.0;\n                                                    float b = 0.5;\n                                                    vec2 d = vec2(0.0);\n                                                    for (int i = 0;\n i < 9; i++) \n                                                    {\n                                                        float n = Noise3D(vec3(p, 0.));\n                                                        a += b * n;\n                                                        b *= 0.5;\n                                                        p *= m2 * 2.0;\n                                                    }\n                                                    return SC * 30.0 * a;\n                                                }\nfloat InteresctTerrial(in vec3 ro, in vec3 rd, in float tmin, in float tmax) \n                                                {\n                                                    float t = tmin;\n                                                    for (int i = 0;\n i < 256; i++) \n                                                    {\n                                                        vec3 p = ro + t * rd;\n                                                        float h = p.y - TerrainH(p.xz);\n                                                        if (h < (0.002 * t) || t > tmax) break;\n                                                         t += 0.9 * h;\n                                                    }\n                                                    return t;\n                                                }\nvec3 CalcTerrianNormal(in vec3 pos, float t) \n                                                {\n                                                    vec2 eps = vec2(0.002 * t, 0.0);\n                                                    return normalize(vec3(TerrainH(pos.xz - eps.xy) - TerrainH(pos.xz + eps.xy), 2.0 * eps.x, TerrainH(pos.xz - eps.yx) - TerrainH(pos.xz + eps.yx)));\n                                                }\nvec3 RayMarchTerrial(vec3 ro, vec3 rd, float rz) \n                                                {\n                                                    vec3 col = vec3(0., 0., 0.);\n                                                    vec3 pos = ro + rz * rd;\n                                                    vec3 nor = CalcTerrianNormal(pos, rz);\n                                                    vec3 ref = reflect(rd, nor);\n                                                    float fre = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n                                                    vec3 hal = normalize(lightDir - rd);\n                                                    col = vec3(0.08, 0.05, 0.03);\n                                                    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n                                                    float dif = clamp(dot(lightDir, nor), 0.0, 1.0);\n                                                    float bac = clamp(0.2 + 0.8 * dot(normalize(vec3(-lightDir.x, 0.0, lightDir.z)), nor), 0.0, 1.0);\n                                                    float sh = 1.0;\n                                                    vec3 lin = vec3(0.0, 0.0, 0.0);\n                                                    lin += dif * vec3(7.00, 5.00, 3.00) * 1.3;\n                                                    lin += amb * vec3(0.40, 0.60, 1.00) * 1.2;\n                                                    lin += bac * vec3(0.40, 0.50, 0.60);\n                                                    col *= lin;\n                                                    float fo = 1.0 - exp(-pow(0.001 * rz / SC, 1.5));\n                                                    vec3 fco = 0.65 * vec3(0.4, 0.65, 1.0);\n                                                    col = mix(col, fco, fo);\n                                                    return col;\n                                                }\nvec3 Cloud(vec3 bgCol, vec3 ro, vec3 rd, vec3 cloudCol, float spd) \n                                                {\n                                                    vec3 col = bgCol;\n                                                    float t = time * 0.15 * spd;\n                                                    vec2 sc = ro.xz + rd.xz * ((3.) * 40000.0 - ro.y) / rd.y;\n                                                    vec2 p = 0.00002 * sc;\n                                                    float f = 0.0;\n                                                    float s = 0.5;\n                                                    float sum = 0.;\n                                                    for (int i = 0;\n i < 5; i++) \n                                                    {\n                                                        p += t;\n                                                        t *= 1.5;\n                                                        f += s * texture2D(iChannel0, p / 256.0, 0.0).x;\n                                                        p = m2 * p * 2.02;\n                                                        sum += s;\n                                                        s *= 0.6;\n                                                    }\n                                                    float val = f / sum;\n                                                    col = mix(col, cloudCol, 0.5 * smoothstep(0.5, 0.8, val));\n                                                    return col;\n                                                }\nvec3 RayMarchCloud(vec3 ro, vec3 rd) \n                                                {\n                                                    vec3 col = vec3(0.0, 0.0, 0.0);\n                                                    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n                                                    col = vec3(0.2, 0.5, 0.85) * 1.1 - rd.y * rd.y * 0.5;\n                                                    col = mix(col, 0.85 * vec3(0.7, 0.75, 0.85), pow(1.0 - max(rd.y, 0.0), 4.0));\n                                                    col += 0.25 * vec3(1.0, 0.7, 0.4) * pow(sundot, 5.0);\n                                                    col += 0.25 * vec3(1.0, 0.8, 0.6) * pow(sundot, 64.0);\n                                                    col += 0.4 * vec3(1.0, 0.8, 0.6) * pow(sundot, 512.0);\n                                                    col = Cloud(col, ro, rd, vec3(1.0, 0.95, 1.0), 1.);\n                                                    col = mix(col, 0.68 * vec3(0.4, 0.65, 1.0), pow(1.0 - max(rd.y, 0.0), 16.0));\n                                                    return col;\n                                                }\nvarying vec3 LighterGrade1627060293378_181_vPosition;\nvarying vec3 LighterGrade1627060293378_181_vNormal;\nvarying vec2 LighterGrade1627060293378_181_vUv;\nvarying vec2 LighterGrade1627060293378_181_vUv2;\nvec4 Big_Wiggles1627054260628_441_main() \n                                                {\n                                                    vec4 Big_Wiggles1627054260628_441_gl_FragColor = vec4(0.0);\n                                                    Big_Wiggles1627054260628_441_gl_FragColor = vec4(Big_Wiggles1627054260628_441_color * clamp(vNoise, 0.0, 1.0), 1.0);\n                                                    return Big_Wiggles1627054260628_441_gl_FragColor *= 1.0;\n                                                }\nvec4 Tiling_4D_Perlin_Noise1627059836531_99_main() \n                                                {\n                                                    vec4 Tiling_4D_Perlin_Noise1627059836531_99_gl_FragColor = vec4(0.0);\n                                                    float s = Tiling_4D_Perlin_Noise1627059836531_99_vUv.x * uvScale.x;\n                                                    float t = Tiling_4D_Perlin_Noise1627059836531_99_vUv.y * uvScale.y;\n                                                    float multiplier = 1.0 / (2.0 * PI);\n                                                    float nx = cos(s * 2.0 * PI) * multiplier;\n                                                    float ny = cos(t * 2.0 * PI) * multiplier;\n                                                    float nz = sin(s * 2.0 * PI) * multiplier;\n                                                    float nw = sin(t * 2.0 * PI) * multiplier;\n                                                    float surf = surface(vec4(nx, ny, nz, nw) + time * Tiling_4D_Perlin_Noise1627059836531_99_speed);\n                                                    Tiling_4D_Perlin_Noise1627059836531_99_gl_FragColor = vec4(Tiling_4D_Perlin_Noise1627059836531_99_color * vec3(surf), 1.0);\n                                                    return Tiling_4D_Perlin_Noise1627059836531_99_gl_FragColor *= 1.0;\n                                                }\nvec4 New_Basic_Shader1627059930592_142_main() \n                                                {\n                                                    vec4 New_Basic_Shader1627059930592_142_gl_FragColor = vec4(0.0);\n                                                    float maxT = 10000.;\n                                                    float minT = 0.1;\n                                                    vec3 col = vec3(0., 0., 0.);\n                                                    float waterT = maxT;\n                                                    vec3 ro = vec3(-79., 104., -4.0);\n                                                    vec3 rd = InitCam(gl_FragCoord.xy);\n                                                    if (rd.y < -0.01) \n                                                    {\n                                                        float t = -(ro.y - waterHeight) / rd.y;\n                                                        waterT = min(waterT, t);\n                                                    }\n                                                     float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n                                                    float rz = InteresctTerrial(ro, rd, minT, maxT);\n                                                    float fresnel = 0.;\n                                                    vec3 refractCol = vec3(0., 0., 0.);\n                                                    bool reflected = false;\n                                                    if (rd.y < -0.01) \n                                                    {\n                                                        vec3 waterPos = ro + rd * waterT;\n                                                        vec3 nor = WaterNormal(waterPos, waterT);\n                                                        float ndotr = dot(nor, -rd);\n                                                        fresnel = pow(1.0 - abs(ndotr), 6.);\n                                                        float diff = pow(dot(nor, lightDir) * 0.4 + 0.6, 3.);\n                                                        vec3 waterCol = _BaseWaterColor + diff * _LightWaterColor * 0.12;\n                                                        float transPer = pow(1.0 - clamp(rz - waterT, 0., waterTranDeep) / waterTranDeep, 3.);\n                                                        vec3 bgCol = RayMarchTerrial(ro, rd + nor * clamp(1. - dot(rd, -nor), 0., 1.), rz);\n                                                        refractCol = mix(waterCol, bgCol, transPer);\n                                                        ro = waterPos;\n                                                        rd = reflect(rd, nor);\n                                                        rz = InteresctTerrial(ro, rd, minT, maxT);\n                                                        reflected = true;\n                                                        col = refractCol;\n                                                    }\n                                                     if (reflected == true) \n                                                    {\n                                                        col = mix(refractCol, col, fresnel);\n                                                        float spec = pow(max(dot(rd, lightDir), 0.0), 128.) * 3.;\n                                                        col += vec3(spec, spec, spec);\n                                                    }\n                                                     if (reflected == true) \n                                                    {\n                                                        col = mix(refractCol, col, fresnel);\n                                                        float spec = pow(max(dot(rd, lightDir), 0.0), 128.) * 3.;\n                                                        col += vec3(spec, spec, spec);\n                                                    }\n                                                     New_Basic_Shader1627059930592_142_gl_FragColor = vec4(col, 1.0);\n                                                    return New_Basic_Shader1627059930592_142_gl_FragColor *= 1.0;\n                                                }\nvec4 LighterGrade1627060293378_181_main() \n                                                {\n                                                    vec4 LighterGrade1627060293378_181_gl_FragColor = vec4(0.0);\n                                                    vec3 worldPosition = (modelMatrix * vec4(LighterGrade1627060293378_181_vPosition, 1.0)).xyz;\n                                                    vec3 worldNormal = normalize(vec3(modelMatrix * vec4(LighterGrade1627060293378_181_vNormal, 0.0)));\n                                                    vec3 lightVector = normalize(LighterGrade1627060293378_181_lightPosition - worldPosition);\n                                                    float brightness = dot(worldNormal, lightVector);\n                                                    LighterGrade1627060293378_181_gl_FragColor = vec4(LighterGrade1627060293378_181_color * brightness + color2, 1.0);\n                                                    return LighterGrade1627060293378_181_gl_FragColor *= 1.0;\n                                                }\nvoid main() \n                                                {\n                                                    gl_FragColor = (Big_Wiggles1627054260628_441_main() + Tiling_4D_Perlin_Noise1627059836531_99_main() + New_Basic_Shader1627059930592_142_main() + LighterGrade1627060293378_181_main());                                                }\n",
  "vertex": "precision highp float;\nprecision highp int;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform float scale;\nuniform float displacement;\nuniform float time;\nuniform float Big_Wiggles1627054260628_441_speed;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\nvarying float vNoise;\nvec3 Big_Wiggles1627054260628_441_mod289(vec3 x) \n                                                {\n                                                    return x - floor(x * (1.0 / 289.0)) * 289.0;\n                                                }\nvec4 Big_Wiggles1627054260628_441_mod289(vec4 x) \n                                                {\n                                                    return x - floor(x * (1.0 / 289.0)) * 289.0;\n                                                }\nvec4 Big_Wiggles1627054260628_441_permute(vec4 x) \n                                                {\n                                                    return Big_Wiggles1627054260628_441_mod289(((x * 34.0) + 1.0) * x);\n                                                }\nvec4 Big_Wiggles1627054260628_441_taylorInvSqrt(vec4 r) \n                                                {\n                                                    return 1.79284291400159 - 0.85373472095314 * r;\n                                                }\nvec3 fade(vec3 t) \n                                                {\n                                                    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n                                                }\nfloat cnoise(vec3 P) \n                                                {\n                                                    vec3 Pi0 = floor(P);\n                                                    vec3 Pi1 = Pi0 + vec3(1.0);\n                                                    Pi0 = Big_Wiggles1627054260628_441_mod289(Pi0);\n                                                    Pi1 = Big_Wiggles1627054260628_441_mod289(Pi1);\n                                                    vec3 Pf0 = fract(P);\n                                                    vec3 Pf1 = Pf0 - vec3(1.0);\n                                                    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n                                                    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n                                                    vec4 iz0 = Pi0.zzzz;\n                                                    vec4 iz1 = Pi1.zzzz;\n                                                    vec4 ixy = Big_Wiggles1627054260628_441_permute(Big_Wiggles1627054260628_441_permute(ix) + iy);\n                                                    vec4 ixy0 = Big_Wiggles1627054260628_441_permute(ixy + iz0);\n                                                    vec4 ixy1 = Big_Wiggles1627054260628_441_permute(ixy + iz1);\n                                                    vec4 gx0 = ixy0 * (1.0 / 7.0);\n                                                    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n                                                    gx0 = fract(gx0);\n                                                    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n                                                    vec4 sz0 = step(gz0, vec4(0.0));\n                                                    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n                                                    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n                                                    vec4 gx1 = ixy1 * (1.0 / 7.0);\n                                                    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n                                                    gx1 = fract(gx1);\n                                                    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n                                                    vec4 sz1 = step(gz1, vec4(0.0));\n                                                    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n                                                    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n                                                    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n                                                    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n                                                    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n                                                    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n                                                    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n                                                    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n                                                    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n                                                    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n                                                    vec4 norm0 = Big_Wiggles1627054260628_441_taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n                                                    g000 *= norm0.x;\n                                                    g010 *= norm0.y;\n                                                    g100 *= norm0.z;\n                                                    g110 *= norm0.w;\n                                                    vec4 norm1 = Big_Wiggles1627054260628_441_taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n                                                    g001 *= norm1.x;\n                                                    g011 *= norm1.y;\n                                                    g101 *= norm1.z;\n                                                    g111 *= norm1.w;\n                                                    float n000 = dot(g000, Pf0);\n                                                    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n                                                    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n                                                    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n                                                    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n                                                    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n                                                    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n                                                    float n111 = dot(g111, Pf1);\n                                                    vec3 fade_xyz = fade(Pf0);\n                                                    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n                                                    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n                                                    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n                                                    return 2.2 * n_xyz;\n                                                }\nvarying vec3 Tiling_4D_Perlin_Noise1627059836531_99_vPosition;\nvarying vec3 Tiling_4D_Perlin_Noise1627059836531_99_vNormal;\nvarying vec2 Tiling_4D_Perlin_Noise1627059836531_99_vUv;\nvarying vec2 Tiling_4D_Perlin_Noise1627059836531_99_vUv2;\nvarying vec3 New_Basic_Shader1627059930592_142_vPosition;\nvarying vec3 New_Basic_Shader1627059930592_142_vNormal;\nvarying vec2 New_Basic_Shader1627059930592_142_vUv;\nvarying vec2 New_Basic_Shader1627059930592_142_vUv2;\nvarying vec3 LighterGrade1627060293378_181_vPosition;\nvarying vec3 LighterGrade1627060293378_181_vNormal;\nvarying vec2 LighterGrade1627060293378_181_vUv;\nvarying vec2 LighterGrade1627060293378_181_vUv2;\nvec4 Big_Wiggles1627054260628_441_main() \n                                                {\n                                                    vec4 Big_Wiggles1627054260628_441_gl_Position = vec4(0.0);\n                                                    vNoise = cnoise(normalize(position) * scale + (time * Big_Wiggles1627054260628_441_speed));\n                                                    vec3 pos = position + normal * vNoise * vec3(displacement);\n                                                    Big_Wiggles1627054260628_441_gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n                                                    return Big_Wiggles1627054260628_441_gl_Position *= 1.0;\n                                                }\nvec4 Tiling_4D_Perlin_Noise1627059836531_99_main() \n                                                {\n                                                    vec4 Tiling_4D_Perlin_Noise1627059836531_99_gl_Position = vec4(0.0);\n                                                    Tiling_4D_Perlin_Noise1627059836531_99_vNormal = normal;\n                                                    Tiling_4D_Perlin_Noise1627059836531_99_vUv = uv;\n                                                    Tiling_4D_Perlin_Noise1627059836531_99_vUv2 = uv2;\n                                                    Tiling_4D_Perlin_Noise1627059836531_99_vPosition = position;\n                                                    Tiling_4D_Perlin_Noise1627059836531_99_gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                                                    return Tiling_4D_Perlin_Noise1627059836531_99_gl_Position *= 1.0;\n                                                }\nvec4 New_Basic_Shader1627059930592_142_main() \n                                                {\n                                                    vec4 New_Basic_Shader1627059930592_142_gl_Position = vec4(0.0);\n                                                    New_Basic_Shader1627059930592_142_vNormal = normal;\n                                                    New_Basic_Shader1627059930592_142_vUv = uv;\n                                                    New_Basic_Shader1627059930592_142_vUv2 = uv2;\n                                                    New_Basic_Shader1627059930592_142_vPosition = position;\n                                                    New_Basic_Shader1627059930592_142_gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                                                    return New_Basic_Shader1627059930592_142_gl_Position *= 1.0;\n                                                }\nvec4 LighterGrade1627060293378_181_main() \n                                                {\n                                                    vec4 LighterGrade1627060293378_181_gl_Position = vec4(0.0);\n                                                    LighterGrade1627060293378_181_vNormal = normal;\n                                                    LighterGrade1627060293378_181_vUv = uv;\n                                                    LighterGrade1627060293378_181_vUv2 = uv2;\n                                                    LighterGrade1627060293378_181_vPosition = position;\n                                                    LighterGrade1627060293378_181_gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                                                    return LighterGrade1627060293378_181_gl_Position *= 1.0;\n                                                }\nvoid main() \n                                                {\n                                                    gl_Position = Big_Wiggles1627054260628_441_main() + Tiling_4D_Perlin_Noise1627059836531_99_main() + New_Basic_Shader1627059930592_142_main() + LighterGrade1627060293378_181_main();                                                }\n",
  "uniforms": {
    "displacement": {
      "value": "1.5",
      "type": "f",
      "glslType": "float"
    },
    "time": {
      "type": "f",
      "glslType": "float"
    },
    "scale": {
      "value": "1",
      "type": "f",
      "glslType": "float"
    },
    "Big_Wiggles1627054260628_441_color": {
      "value": {
        "r": 1,
        "g": 1,
        "b": 1
      },
      "type": "c",
      "glslType": "vec3"
    },
    "Big_Wiggles1627054260628_441_speed": {
      "value": "1.5",
      "type": "f",
      "glslType": "float"
    },
    "cameraPosition": {
      "type": "v3",
      "glslType": "vec3"
    },
    "uvScale": {
      "value": {
        "x": "1",
        "y": "1"
      },
      "type": "v2",
      "glslType": "vec2"
    },
    "Tiling_4D_Perlin_Noise1627059836531_99_color": {
      "value": {
        "r": 0,
        "g": 0,
        "b": 0
      },
      "type": "c",
      "glslType": "vec3"
    },
    "Tiling_4D_Perlin_Noise1627059836531_99_speed": {
      "value": "0.01",
      "type": "f",
      "glslType": "float"
    },
    "iChannel0": {
      "value": null,
      "type": "t",
      "glslType": "sampler2D"
    },
    "New_Basic_Shader1627059930592_142_color": {
      "value": {
        "r": 0.4980392156862745,
        "g": 0.596078431372549,
        "b": 0.2627450980392157
      },
      "type": "c",
      "glslType": "vec3"
    },
    "New_Basic_Shader1627059930592_142_lightPosition": {
      "value": {
        "x": 0,
        "y": 1.25,
        "z": 1.25
      },
      "type": "v3",
      "glslType": "vec3"
    },
    "color2": {
      "value": {
        "r": 0.11764705882352941,
        "g": 0.2196078431372549,
        "b": 0.1803921568627451
      },
      "type": "c",
      "glslType": "vec3"
    },
    "LighterGrade1627060293378_181_color": {
      "value": {
        "r": 0.6823529411764706,
        "g": 0.8862745098039215,
        "b": 0.2235294117647059
      },
      "type": "c",
      "glslType": "vec3"
    },
    "LighterGrade1627060293378_181_lightPosition": {
      "value": {
        "x": 0,
        "y": 1.25,
        "z": 1.25
      },
      "type": "v3",
      "glslType": "vec3"
    }
  },
  "url": "http://shaderfrog.com/app/view/5371",
  "user": {
    "username": "lotusotho",
    "url": "http://shaderfrog.com/app/profile/andrewray"
  }
}